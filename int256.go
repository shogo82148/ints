package ints

import (
	"cmp"
	"math/bits"
)

// Int256 is a type that represents an 256-bit signed integer.
type Int256 [4]uint64

// Add returns the sum a+b.
//
// This function's execution time does not depend on the inputs.
func (a Int256) Add(b Int256) Int256 {
	u3, carry := bits.Add64(a[3], b[3], 0)
	u2, carry := bits.Add64(a[2], b[2], carry)
	u1, carry := bits.Add64(a[1], b[1], carry)
	u0, _ := bits.Add64(a[0], b[0], carry)
	return Int256{u0, u1, u2, u3}
}

// Sub returns the difference a-b.
//
// This function's execution time does not depend on the inputs.
func (a Int256) Sub(b Int256) Int256 {
	u3, borrow := bits.Sub64(a[3], b[3], 0)
	u2, borrow := bits.Sub64(a[2], b[2], borrow)
	u1, borrow := bits.Sub64(a[1], b[1], borrow)
	u0, _ := bits.Sub64(a[0], b[0], borrow)
	return Int256{u0, u1, u2, u3}
}

// Mul returns the product a*b.
func (a Int256) Mul(b Int256) Int256 {
	neg := false
	if a.Sign() < 0 {
		a = a.Neg()
		neg = true
	}
	if b.Sign() < 0 {
		b = b.Neg()
		neg = !neg
	}

	c := Int256(Uint256(a).Mul(Uint256(b)))

	if neg {
		return c.Neg()
	}
	return c
}

// Lsh returns the logical left shift a<<i.
//
// This function's execution time does not depend on the inputs.
func (a Int256) Lsh(i uint) Int256 {
	// This operation may overflow, but it's okay because when it overflows,
	// the result is always greater than or equal to 64.
	// And shifts of 64 bits or more always result in 0, so they don't affect the final result.
	n1 := uint(i - 64)
	n2 := uint(64 - i)
	n3 := uint(i - 128)
	n4 := uint(128 - i)
	n5 := uint(i - 192)
	n6 := uint(192 - i)

	return Int256{
		a[0]<<i | a[1]<<n1 | a[1]>>n2 | a[2]<<n3 | a[2]>>n4 | a[3]<<n5 | a[3]>>n6,
		a[1]<<i | a[2]<<n1 | a[2]>>n2 | a[3]<<n3 | a[3]>>n4,
		a[2]<<i | a[3]<<n1 | a[3]>>n2,
		a[3] << i,
	}
}

// Rsh returns the arithmetic right shift a>>i, preserving the sign bit.
//
// This function's execution time does not depend on the inputs.
func (a Int256) Rsh(i uint) Int256 {
	// This operation may overflow, but it's okay because when it overflows,
	// the result is always greater than or equal to 64.
	// And shifts of 64 bits or more always result in 0, so they don't affect the final result.
	n1, v1 := bits.Sub(i, 64, 0)
	n2 := uint(64 - i)
	n3, v3 := bits.Sub(i, 128, 0)
	n4 := uint(128 - i)
	n5, v5 := bits.Sub(i, 192, 0)
	n6 := uint(192 - i)

	mask1 := uint64(int(v1) - 1)
	mask3 := uint64(int(v3) - 1)
	mask5 := uint64(int(v5) - 1)

	return Int256{
		uint64(int64(a[0]) >> i),
		a[1]>>i | mask1&uint64(int64(a[0])>>n1) | a[0]<<n2,
		a[2]>>i | a[1]>>n1 | a[1]<<n2 | mask3&uint64(int64(a[0])>>n3) | a[0]<<n4,
		a[3]>>i | a[2]>>n1 | a[2]<<n2 | a[1]>>n3 | a[1]<<n4 | mask5&uint64(int64(a[0])>>n5) | a[0]<<n6,
	}
}

// Sign returns the sign of a.
// It returns 1 if a > 0, -1 if a < 0, and 0 if a == 0.
func (a Int256) Sign() int {
	var zero Int256
	switch {
	case a == zero:
		return 0
	case int64(a[0]) < 0:
		return -1
	default:
		return 1
	}
}

// Neg returns the negation of a.
//
// This function's execution time does not depend on the inputs.
func (a Int256) Neg() Int256 {
	u3, borrow := bits.Sub64(0, a[3], 0)
	u2, borrow := bits.Sub64(0, a[2], borrow)
	u1, borrow := bits.Sub64(0, a[1], borrow)
	u0, _ := bits.Sub64(0, a[0], borrow)
	return Int256{u0, u1, u2, u3}
}

func (a Int256) Cmp(b Int256) int {
	if ret := cmp.Compare(int64(a[0]), int64(b[0])); ret != 0 {
		return ret
	}
	sign := 1
	if int64(a[0]) < 0 {
		sign = -1
	}
	if ret := cmp.Compare(a[1], b[1]); ret != 0 {
		return ret * sign
	}
	if ret := cmp.Compare(a[2], b[2]); ret != 0 {
		return ret * sign
	}
	return cmp.Compare(a[3], b[3]) * sign
}

// Text returns the string representation of a in the given base.
// Base must be between 2 and 62, inclusive.
// The result uses the lower-case letters 'a' to 'z' for digit values 10 to 35,
// and the upper-case letters 'A' to 'Z' for digit values 36 to 61. No prefix (such as "0x") is added to the string.
func (a Int256) Text(base int) string {
	_, s := formatBits256(nil, a[0], a[1], a[2], a[3], base, int64(a[0]) < 0, false)
	return s
}

// Append appends the string representation of a, as generated by a.Text(base), to buf and returns the extended buffer.
func (a Int256) Append(dst []byte, base int) []byte {
	d, _ := formatBits256(dst, a[0], a[1], a[2], a[3], base, int64(a[0]) < 0, true)
	return d
}

// AppendText implements the [encoding.TextAppender] interface.
func (a Int256) AppendText(dst []byte) ([]byte, error) {
	d, _ := formatBits256(dst, a[0], a[1], a[2], a[3], 10, int64(a[0]) < 0, true)
	return d, nil
}

// String returns the string representation of a in base 10.
func (a Int256) String() string {
	_, s := formatBits256(nil, a[0], a[1], a[2], a[3], 10, int64(a[0]) < 0, false)
	return s
}
